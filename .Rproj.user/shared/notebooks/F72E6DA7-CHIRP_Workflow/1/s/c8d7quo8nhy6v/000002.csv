"0","```r
library(Matrix)
library(Seurat)
```"
"1","Registered S3 method overwritten by 'htmlwidgets':
  method           from         
  print.htmlwidget tools:rstudio
Attaching SeuratObject
"
"0","```r
library(dplyr)
```"
"1","
Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
"
"0","```r
library(plyr)
```"
"1","--------------------------------------------------------------------------------------------------------------------------------------
You have loaded plyr after dplyr - this is likely to cause problems.
If you need functions from both plyr and dplyr, please load plyr first, then dplyr:
library(plyr); library(dplyr)
--------------------------------------------------------------------------------------------------------------------------------------

Attaching package: ‘plyr’

The following objects are masked from ‘package:dplyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise, summarize
"
"0","```r
library(ggcyto)
```"
"1","Loading required package: ggplot2
Loading required package: flowCore

Attaching package: ‘flowCore’

The following object is masked from ‘package:Matrix’:

    %&%

Loading required package: ncdfFlow
Loading required package: RcppArmadillo
Loading required package: BH
Loading required package: flowWorkspace
As part of improvements to flowWorkspace, some behavior of
GatingSet objects has changed. For details, please read the section
titled \"The cytoframe and cytoset classes\" in the package vignette:

  vignette(\"flowWorkspace-Introduction\", \"flowWorkspace\")
"
"0","```r
library(RColorBrewer)
library(cowplot)
library(scRepertoire)
library(circlize)
```"
"1","========================================
circlize version 0.4.13
CRAN page: https://cran.r-project.org/package=circlize
Github page: https://github.com/jokergoo/circlize
Documentation: https://jokergoo.github.io/circlize_book/book/

If you use it in published research, please cite:
Gu, Z. circlize implements and enhances circular visualization
  in R. Bioinformatics 2014.

This message can be suppressed by:
  suppressPackageStartupMessages(library(circlize))
========================================
"
"0","```r
library(scales)
library(viridis)
```"
"1","Loading required package: viridisLite

Attaching package: ‘viridis’

The following object is masked from ‘package:scales’:

    viridis_pal
"
"0","```r
source('~/OneDrive - Emory University/Ghosn_Lab/scRNA_Data/VDJ_Tools.R')
```"
"1","Loading required package: Biostrings
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: ‘BiocGenerics’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following object is masked from ‘package:flowCore’:

    normalize

The following objects are masked from ‘package:dplyr’:

    combine, intersect, setdiff, union

The following objects are masked from ‘package:stats’:

    IQR, mad, sd, var, xtabs

The following objects are masked from ‘package:base’:

    anyDuplicated, append, as.data.frame, basename, cbind, colnames, dirname, do.call, duplicated, eval, evalq, Filter,
    Find, get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, order, paste, pmax, pmax.int, pmin,
    pmin.int, Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, union, unique, unsplit,
    which.max, which.min

Loading required package: S4Vectors
Loading required package: stats4

Attaching package: ‘S4Vectors’

The following object is masked from ‘package:plyr’:

    rename

The following objects are masked from ‘package:dplyr’:

    first, rename

The following object is masked from ‘package:Matrix’:

    expand

The following object is masked from ‘package:base’:

    expand.grid

Loading required package: IRanges

Attaching package: ‘IRanges’

The following object is masked from ‘package:plyr’:

    desc

The following objects are masked from ‘package:dplyr’:

    collapse, desc, slice

Loading required package: XVector

Attaching package: ‘XVector’

The following object is masked from ‘package:plyr’:

    compact


Attaching package: ‘Biostrings’

The following object is masked from ‘package:base’:

    strsplit

Loading required package: stringr
Loading required package: readr

Attaching package: ‘readr’

The following object is masked from ‘package:scales’:

    col_factor

Loading required package: purrr

Attaching package: ‘purrr’

The following object is masked from ‘package:XVector’:

    compact

The following object is masked from ‘package:IRanges’:

    reduce

The following object is masked from ‘package:scales’:

    discard

The following object is masked from ‘package:plyr’:

    compact

Loading required package: Peptides
"
"0","```r
colors.use <- c(brewer.pal(8, 'Set1')[c(1:5,7:8)], brewer.pal(7, 'Dark2'),  'blue4', 'orangered', 'orangered4', c(brewer.pal(12, 'Paired'), brewer.pal(6, 'Accent'))[c(1:10, 12, 15:20)])
emory.cols <- c(\"#00aeef\",\"#41b6e6\",\"#487f84\",\"#348338\",\"#006c5b\",\"#5c8118\",\"#c35413\",\"#da291c\",\"#c6007e\",\"#6558b1\",\"#6d2077\",\"#000000\")

# Function to z-score each PC's percentage of the total variance captured
TestPCA <- function(object = NULL, 
                    genes.use = object@assays$RNA@var.features,
                    mtx.use = object@assays$RNA@scale.data){
  data.use <- mtx.use[genes.use, ]
  pca.results <- svd(x = t(data.use))
  sdev <- pca.results$d/sqrt(max(1, ncol(data.use) - 1))
  PCVariance <- rbind(SD = sdev,
                      Proportion = (sdev^2)/sum(sdev^2), 
                      Cumulative = cumsum(sdev^2)/sum(sdev^2))
  m <- mean(PCVariance['Proportion', ])
  s <- sd(PCVariance['Proportion', ])
  PCVariance <- rbind(PCVariance, 
                      ZScore = (PCVariance['Proportion', ] - m)/s)
  return(PCVariance)
}
# Function to select mitochondrial percent by X Std Dev above median
MitoFilter <- function(obj){
  max.mito <<- 5*sd(obj$percent.mito) + median(obj$percent.mito)
  obj <- obj %>% subset(percent.mito < max.mito) %>% subset(nFeature_RNA > 100)
  return(obj)
  rm(max.mito)
}

GetLISI <- function(object, nSamples) {
  coords <- object@reductions$umap@cell.embeddings
  sample_cats <- data.frame(\"orig.ident\" = object@meta.data$orig.ident)
  res <- lisi::compute_lisi(coords, sample_cats, c('orig.ident'))
  sample.lisi <- median(res$orig.ident)
  adjusted.lisi <- 1 - ((sample.lisi - 1) / (nSamples - 1))
  return(adjusted.lisi)
}

#### For FeaturePlot() ####
# Function to pseudo customize FeaturePlots
customize_Seurat_FeaturePlot <- function(p, alpha.use = 1, gradient.use = c(\"yellow\", \"red\"), expression.threshold = 0, is.log1p.transformed = F) {
  
  #### Main function ####
  main_function <- function(p = p, alpha.use = alpha.use, gradient.use = gradient.use, expression.threshold = expression.threshold, is.log1p.transformed = is.log1p.transformed) {
    
    # Order data by gene expresion level
    p$data <- p$data[order(p$data$gene),]
    
    # Define lower limit of gene expression level
    if (isTRUE(is.log1p.transformed)) {
      expression.threshold <- expression.threshold
    } else {
      expression.threshold <- log1p(expression.threshold)
    }
    
    # Compute maximum value in gene expression
    max.exp <- max(p$data$gene)
    
    # Fill points using the gene expression levels
    p$layers[[1]]$mapping$fill <- p$layers[[1]]$mapping$colour
    
    # Define transparency of points
    p$layers[[1]]$mapping$alpha <- alpha.use
    
    # Change fill and colour gradient values
    p <- p + scale_colour_gradientn(colours = gradient.use, guide = F, limits = c(expression.threshold, max.exp), na.value = \"grey\") +
      scale_fill_gradientn(colours = gradient.use, name = expression(atop(Expression, (log))), limits = c(expression.threshold, max.exp), na.value = \"grey\") +
      scale_alpha_continuous(range = alpha.use, guide = F)
  }
  
  #### Execution of main function ####
  # Apply main function on all features
  p <- lapply(X = p, alpha.use = alpha.use, gradient.use = gradient.use, 
              expression.threshold = expression.threshold, is.log1p.transformed = is.log1p.transformed,
              FUN = main_function)
  
  # Arrange all plots using cowplot
  # Adapted from Seurat
  # https://github.com/satijalab/seurat/blob/master/R/plotting.R#L1100
  # ncol argument adapted from Josh O'Brien
  # https://stackoverflow.com/questions/10706753/how-do-i-arrange-a-variable-list-of-plots-using-grid-arrange
  cowplot::plot_grid(plotlist = p, ncol = ceiling(sqrt(length(p))))
}

# Correcting VDJ matrix barcodes to Seurat format
rearrange.BC <- function(x){
  toupper(trimws(unlist(lapply(strsplit(x, \"-\"), '[[', 1))))
}

addVDJ <- function(obj = NULL, SampleID = NULL, lineage_df = NULL, cellrangervdj = NULL){
  # Read in single-sample VDJ matrix with lineages & filter to IGH-only
  VDJt <- as.data.frame(lineage_df)
  crVDJ <- read.csv(cellrangervdj)
  crVDJ.umi <- tapply(crVDJ$umis, crVDJ$barcode, FUN = sum)
  rm(crVDJ)
  
  # Correcting VDJ matrix barcodes to Seurat format
  VDJt$indexed_barcode <- rearrange.BC(VDJt$indexed_barcode)
  VDJt$indexed_barcode <- paste(SampleID, VDJt$indexed_barcode, sep = c(\"_\"))
  cells <- intersect(VDJt$indexed_barcode, colnames(obj))
  
  # Correcting CellRanger VDJ names
  names(crVDJ.umi) <- rearrange.BC(names(crVDJ.umi))
  names(crVDJ.umi) <- paste(SampleID, names(crVDJ.umi), sep = c(\"_\"))
  crVDJ.umi <- crVDJ.umi[cells]
  
  VDJ <- VDJt[which(VDJt$chain_type == \"igh\"), ]
  rownames(VDJ) <- VDJ$indexed_barcode
  VDJ.l.umi <- VDJt[which(VDJt$chain_type == \"igl\"), c(\"indexed_barcode\", \"umis\")]
  rownames(VDJ.l.umi) <- VDJ.l.umi$indexed_barcode
  rm(VDJt)
  
  # Establishing VDJ UMI count data (for plasma cell identification)
  obj@meta.data$nCount_VDJ <- 0
  UMI.mtx <- cbind(VDJ[cells, \"umis\"], VDJ.l.umi[cells, \"umis\"])
  row.names(UMI.mtx) <- cells
  UMI.mtx[is.na(UMI.mtx)] <- 0 
  obj@meta.data[cells, \"nCount_VDJ\"] <- crVDJ.umi[cells]
  obj@meta.data[is.na(obj@meta.data$nCount_VDJ), \"nCount_VDJ\"] <- 0
  #VlnPlot(obj, \"nCount_VDJ\")
  rm(list = c('UMI.mtx', 'VDJ.l.umi'))
  # Transferring clonal lineage ID (from above, 85% CDR3 aa match)
  obj@meta.data$Lineage_ID <- NA
  obj@meta.data[cells, \"Lineage_ID\"] <- VDJ[cells, 'lineage_id']
  # Counting lineage frequency (finding shared lineage IDs)
  lineage_freq <- plyr::count(obj@meta.data$Lineage_ID)
  ## re-order frequency to match Seurat cell barcodes & add as metadata
  lineage_freq <- lineage_freq[match(obj@meta.data$Lineage_ID, lineage_freq$x), \"freq\"]
  obj@meta.data$Lineage_Freq <- lineage_freq
  rm(lineage_freq)
  ## replace \"NA lineage\" cells with 0-count frequency (otherwise \"NA\" is the most frequent lineage)
  obj@meta.data[which(is.na(obj@meta.data$Lineage_ID)), \"Lineage_Freq\"] <- 0
  
  # Add IGH V-gene annotation
  obj@meta.data$IGH_V <- NA
  obj@meta.data[cells, \"IGH_V\"] <- VDJ[cells, \"v_gene\"]
  # Add IGH J-gene annotation
  obj@meta.data$IGH_J <- NA
  obj@meta.data[cells, \"IGH_J\"] <- VDJ[cells, \"j_gene\"]
  # Add IGH VJ-gene annotation
  obj@meta.data$IGH_VJ <- NA
  obj@meta.data[cells, \"IGH_VJ\"] <- paste(VDJ[cells, \"j_gene\"], VDJ[cells, \"v_gene\"], sep = \"_\")
  
  # Add IGH V-gene annotation
  obj@meta.data$CDR3_aa <- NA
  obj@meta.data[cells, \"CDR3_aa\"] <- VDJ[cells, \"aa_gapped_cdr3\"]
  
  # Get V-gene frequency
  V_freq <- plyr::count(obj@meta.data$IGH_V)
  V_freq$freq <- (V_freq$freq/nrow(obj[[]]))*100
  ## re-order frequency to match Seurat cell barcodes & add as metadata
  V_freq <- V_freq[match(obj@meta.data$IGH_V, V_freq$x), \"freq\"]
  obj@meta.data$IGH_V_freq <- V_freq
  rm(V_freq)
  ## replace \"NA V-gene\" cells with 0-count frequency (otherwise \"NA\" is the most frequent V-gene)
  obj@meta.data[which(is.na(obj@meta.data$IGH_V)), \"IGH_V_freq\"] <- 0
  
  # Get VJ-gene frequency
  VJ_freq <- plyr::count(obj@meta.data$IGH_VJ)
  VJ_freq$freq <- (VJ_freq$freq/nrow(obj[[]]))*100
  ## re-order frequency to match Seurat cell barcodes & add as metadata
  VJ_freq <- VJ_freq[match(obj@meta.data$IGH_VJ, VJ_freq$x), \"freq\"]
  obj@meta.data$IGH_VJ_freq <- VJ_freq
  rm(VJ_freq)
  ## replace \"NA V-gene\" cells with 0-count frequency (otherwise \"NA\" is the most frequent V-gene)
  obj@meta.data[which(is.na(obj@meta.data$IGH_J)), \"IGH_VJ_freq\"] <- 0
  
  # Add isotype
  obj@meta.data$Isotype <- NA
  obj@meta.data[cells, \"Isotype\"] <- VDJ[cells, \"isotype\"]
  return(obj)
}


```"
